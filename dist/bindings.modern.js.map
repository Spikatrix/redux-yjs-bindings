{"version":3,"file":"bindings.modern.js","sources":["../src/patchRedux.ts","../src/utils.ts","../src/toSharedType.ts","../src/recursive-diff.types.ts","../src/patchYjs.ts","../src/index.ts"],"sourcesContent":["import { Map as YMap } from 'yjs';\nimport { Store } from 'redux';\n\n/** @desc Action type that is dispatched when yjs state changes from other peers come in. */\nexport const SET_STATE_FROM_YJS_ACTION = 'YJS_INCOMING_CHANGES';\n\nexport const setStateAction = (newState: unknown) => ({\n  type: SET_STATE_FROM_YJS_ACTION,\n  payload: newState,\n});\n\nexport const patchStore = (store: Store, rootMap: YMap<unknown>, sliceName: string) => {\n  store.dispatch(setStateAction(rootMap.toJSON()[sliceName]));\n};\n","export const clamp = (v: number, l: number, u: number) => (v < l ? l : v > u ? u : v);\n\nexport const isObject = (val: unknown): val is Record<string, unknown> =>\n  Object.prototype.toString.call(val) === '[object Object]';\n\nexport const isArray = (val: unknown): val is Array<unknown> => Array.isArray(val);\n\nexport const isString = (val: unknown): val is string =>\n  typeof val === 'string' || val instanceof String;\n\nexport const isInteger = (val: unknown): val is number => Number.isInteger(val);\n","import { Map as YMap, Array as YArray } from 'yjs';\nimport { isArray, isObject } from './utils';\n\n/** @desc Recursively transforms arrays and maps into their respective Yjs class. */\nexport const toSharedType = <Value = unknown>(val: Value) => {\n  if (isArray(val)) {\n    const yArray = new YArray();\n\n    const yValues = val.map((v) => toSharedType(v));\n    yArray.push(yValues); // yArray.push takes an array of values.\n\n    return yArray;\n  } else if (isObject(val)) {\n    const yMap = new YMap();\n\n    Object.entries(val).forEach(([key, v]) => {\n      yMap.set(key, toSharedType(v));\n    });\n\n    return yMap;\n  } else {\n    return val;\n  }\n};\n","// The types exported by recursive-diff are not always correct (e.g. path is actually optional).\n\nexport enum RecursiveDiffResultOperation {\n  Add = 'add',\n  Update = 'update',\n  Delete = 'delete',\n}\n\nexport interface RecursiveDiffResultAdd {\n  op: RecursiveDiffResultOperation.Add;\n  path?: Array<string | number>;\n  val: unknown;\n}\n\nexport interface RecursiveDiffResultUpdate {\n  op: RecursiveDiffResultOperation.Update;\n  path?: Array<string | number>;\n  val: unknown;\n}\n\nexport interface RecursiveDiffResultDelete {\n  op: RecursiveDiffResultOperation.Delete;\n  path?: Array<string | number>;\n  val: undefined;\n}\n\nexport type RecursiveDiffResult = Array<\n  RecursiveDiffResultAdd | RecursiveDiffResultUpdate | RecursiveDiffResultDelete\n>;\n","import { Map as YMap, Array as YArray } from 'yjs';\nimport { getDiff } from 'recursive-diff';\nimport { clamp, isInteger, isString } from './utils';\nimport { toSharedType } from './toSharedType';\nimport { RecursiveDiffResult, RecursiveDiffResultOperation } from './recursive-diff.types';\n\n/** @desc Handles the operation from recursive-diff to patch the given yType */\nconst patchYType = (\n  yType: YMap<unknown> | YArray<unknown>,\n  operation: RecursiveDiffResultOperation,\n  property: string | number, // Either the Map key or Array index\n  value: unknown\n) => {\n  if (\n    operation === RecursiveDiffResultOperation.Add ||\n    operation === RecursiveDiffResultOperation.Update\n  ) {\n    const yValue = toSharedType(value);\n\n    if (yType instanceof YArray && isInteger(property)) {\n      if (operation === RecursiveDiffResultOperation.Update) yType.delete(property);\n\n      yType.insert(property, [yValue]);\n    } else if (yType instanceof YMap && isString(property)) {\n      yType.set(property, yValue);\n    } else {\n      throw new Error('Unsupported YAbstractType or property type did not match.');\n    }\n  } else if (operation === RecursiveDiffResultOperation.Delete) {\n    if (yType instanceof YArray && isInteger(property)) {\n      // This actually only works because the \"recursive-diff\" cancels inserts and deletions out into update operations\n      // [1, 2, 3] => [3] into [{op: 'update', index: 0, val: 3}, {op: 'del', index: 1}, {op: 'del', index: 2}]\n      // Therefore delete or insert operations are always last (never both, since that would be represented as an update).\n      // A more sophisticated solution would group deletions together to a single operation.\n      const clampedIndex = clamp(property, 0, yType.length - 1);\n      yType.delete(clampedIndex);\n    } else if (yType instanceof YMap && isString(property)) {\n      yType.delete(property);\n    } else {\n      throw new Error('Unsupported YAbstractType or property type did not match.');\n    }\n  }\n};\n\n/** @desc Recursively walk through path array until its length is one, at which point it performs the appropriate operation on the remaining property in the path. */\nconst traversePath = (\n  yType: YMap<unknown> | YArray<unknown>,\n  operation: RecursiveDiffResultOperation,\n  path: Array<string | number>,\n  value: unknown\n) => {\n  if (path.length === 0) {\n    throw new Error('Cannot traverse 0 length path.');\n  }\n\n  if (path.length === 1) {\n    patchYType(yType, operation, path[0], value);\n  } else {\n    const [currentSegment, ...restPath] = path;\n\n    if (yType instanceof YArray) {\n      if (!isInteger(currentSegment)) {\n        throw new Error('States diverged.');\n      }\n\n      const nextType = yType.get(currentSegment);\n\n      // NextType must also be an array or map because path.length >= 2.\n      if (!(nextType instanceof YMap || nextType instanceof YArray)) {\n        throw new Error('States diverged.');\n      }\n\n      traversePath(nextType, operation, restPath, value);\n    } else if (yType instanceof YMap) {\n      if (!isString(currentSegment)) {\n        throw new Error('States diverged.');\n      }\n\n      const nextType = yType.get(currentSegment);\n\n      // NextType must also be an array or map because path.length >= 2.\n      if (!(nextType instanceof YMap || nextType instanceof YArray)) {\n        throw new Error('States diverged.');\n      }\n\n      traversePath(nextType, operation, restPath, value);\n    } else {\n      console.warn('Encountered unsupported yType. Received:', yType);\n    }\n  }\n};\n\n/**\n * @desc Takes a rootMap that holds the values at the given sliceName. Then compares the old and new state to find the difference and apply that to the slice in the rootMap.\n * @param rootMap The yMap that holds the values to all slices.\n * @param sliceName Property name that contains the values on the rootMap.\n * @param a The old value.\n * @param b The new value.\n * */\nexport const patchYjs = (rootMap: YMap<unknown>, sliceName: string, a: unknown, b: unknown) => {\n  // Types of getDiff are inaccurate\n  const diff = getDiff(a, b) as RecursiveDiffResult;\n\n  // Applying diff in reverse to avoid problems when removing more than one item from an array,\n  // where the index of the item that should be removed moves after a previous one was removed.\n  // F.e.: diff(1[, 2], []) returns [{op: 'del', idx: 0}, {op: 'del', idx: 1}] but by the time\n  // we try to remove the second element, the array only has a length of 1. Thus index 1 would\n  // be out of bounds. Deleting from right to left circumvents this problem, while introducing\n  // it again but for insertions. To solve this problem, items should be inserted from left to\n  // right but removed right to left. A workaround exists inside the patchYType function, that\n  // simply clamps the accessed index to the length of the array. The method is limited to the\n  // recursive-diff algorithm though.\n  // diff.reverse(); // Won't work for multiple consecutive insertions.\n\n  diff.forEach(({ op, path, val }) => {\n    // \"path\" is undefined if a or b are primitive values.\n    traversePath(rootMap, op, [sliceName, ...(path || [])], val);\n  });\n};\n","import { Doc as YDoc, transact } from 'yjs';\nimport { Reducer, Store } from 'redux';\nimport { patchStore, SET_STATE_FROM_YJS_ACTION } from './patchRedux';\nimport { toSharedType } from './toSharedType';\nimport { patchYjs } from './patchYjs';\nimport { isArray, isObject } from './utils';\n\nexport { SET_STATE_FROM_YJS_ACTION } from './patchRedux';\n\n/** @desc This is the name of the yMap that is used on the yDoc that passed to the setup function. Can be used to persist the values on a server. */\nexport const ROOT_MAP_NAME = '__ReduxYjsBindingsRootMap';\n\n/**\n * @desc Initialises the bindings and registers listeners on yjs and teh redux store.\n * @param yDoc The y-document that is used to sync with other peers.\n * @param store The redux store containing the values that should be synced.\n * @param sliceName The name of the redux-subtree (slice) that contains the values.\n * */\nexport const bind = <S extends { [key in string]: any }, K extends keyof S & string>(\n  yDoc: YDoc, \n  store: Store<S>, \n  sliceName: K) => {\n  const rootMap = yDoc.getMap(ROOT_MAP_NAME);\n  const state = store.getState()[sliceName];\n\n  // Set initial values from store, while preventing overriding remote states.\n  if (isObject(state)) {\n    transact(yDoc, () => {\n      rootMap.set(sliceName, toSharedType({}));\n      patchYjs(rootMap, sliceName, {}, state);\n    });\n  }\n\n  if (isArray(state)) {\n    transact(yDoc, () => {\n      rootMap.set(sliceName, toSharedType([]));\n      patchYjs(rootMap, sliceName, [], state);\n    });\n  }\n\n  // Prevent reacting to our own changes.\n  let currentlyPatchingYjs = false;\n  let currentlyPatchingStore = false;\n\n  let currentState = store.getState()[sliceName];\n  store.subscribe(() => {\n    const prevState = currentState;\n    currentState = store.getState()[sliceName];\n\n    if (currentlyPatchingStore) return;\n\n    currentlyPatchingYjs = true;\n    transact(yDoc, () => {\n      patchYjs(rootMap, sliceName, prevState, currentState);\n    });\n    currentlyPatchingYjs = false;\n  });\n\n  rootMap.observeDeep(() => {\n    if (currentlyPatchingYjs) return;\n\n    currentlyPatchingStore = true;\n    patchStore(store, rootMap, sliceName);\n    currentlyPatchingStore = false;\n  });\n};\n\n/** @desc This is a utility function to enhance an existing reducer to react to the actions dispatched that are meant to set the state of the redux slice on incoming changes from yjs. */\nexport const enhanceReducer =\n  <S>(currentReducer: Reducer<S>): Reducer<S> =>\n    (state, action) => {\n      if (action?.type === SET_STATE_FROM_YJS_ACTION) {\n        return action.payload === undefined ? state : action.payload;\n      } else {\n        return currentReducer(state, action);\n      }\n    };\n"],"names":["SET_STATE_FROM_YJS_ACTION","val","Object","prototype","toString","call","isArray","Array","isString","String","isInteger","Number","toSharedType","yArray","YArray","yValues","map","v","push","isObject","YMap","entries","forEach","key","yMap","set","RecursiveDiffResultOperation","traversePath","yType","operation","path","value","length","property","Add","Update","yValue","delete","insert","Delete","clampedIndex","u","Error","patchYType","currentSegment","restPath","nextType","get","console","warn","patchYjs","rootMap","sliceName","a","b","getDiff","op","ROOT_MAP_NAME","yDoc","store","getMap","state","getState","transact","currentlyPatchingYjs","currentlyPatchingStore","currentState","subscribe","prevState","observeDeep","dispatch","type","payload","toJSON","patchStore","enhanceReducer","currentReducer","action","undefined"],"mappings":"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"}