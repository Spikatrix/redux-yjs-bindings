{"version":3,"file":"bindings.module.js","sources":["../src/patchRedux.ts","../src/recursive-diff.types.ts","../src/utils.ts","../src/toSharedType.ts","../src/patchYjs.ts","../src/index.ts"],"sourcesContent":["import { Map as YMap } from 'yjs';\nimport { Store } from 'redux';\n\n/** @desc Action type that is dispatched when yjs state changes from other peers come in. */\nexport const SET_STATE_FROM_YJS_ACTION = 'YJS_INCOMING_CHANGES';\n\nexport const setStateAction = (newState: unknown) => ({\n  type: SET_STATE_FROM_YJS_ACTION,\n  payload: newState,\n});\n\nexport const patchStore = (store: Store, rootMap: YMap<unknown>, sliceName: string) => {\n  store.dispatch(setStateAction(rootMap.toJSON()[sliceName]));\n};\n","// The types exported by recursive-diff are not always correct (e.g. path is actually optional).\n\nexport enum RecursiveDiffResultOperation {\n  Add = 'add',\n  Update = 'update',\n  Delete = 'delete',\n}\n\nexport interface RecursiveDiffResultAdd {\n  op: RecursiveDiffResultOperation.Add;\n  path?: Array<string | number>;\n  val: unknown;\n}\n\nexport interface RecursiveDiffResultUpdate {\n  op: RecursiveDiffResultOperation.Update;\n  path?: Array<string | number>;\n  val: unknown;\n}\n\nexport interface RecursiveDiffResultDelete {\n  op: RecursiveDiffResultOperation.Delete;\n  path?: Array<string | number>;\n  val: undefined;\n}\n\nexport type RecursiveDiffResult = Array<\n  RecursiveDiffResultAdd | RecursiveDiffResultUpdate | RecursiveDiffResultDelete\n>;\n","export const clamp = (v: number, l: number, u: number) => (v < l ? l : v > u ? u : v);\n\nexport const isObject = (val: unknown): val is Record<string, unknown> =>\n  Object.prototype.toString.call(val) === '[object Object]';\n\nexport const isArray = (val: unknown): val is Array<unknown> => Array.isArray(val);\n\nexport const isString = (val: unknown): val is string =>\n  typeof val === 'string' || val instanceof String;\n\nexport const isInteger = (val: unknown): val is number => Number.isInteger(val);\n","import { Map as YMap, Array as YArray } from 'yjs';\nimport { isArray, isObject } from './utils';\n\n/** @desc Recursively transforms arrays and maps into their respective Yjs class. */\nexport const toSharedType = <Value = unknown>(val: Value) => {\n  if (isArray(val)) {\n    const yArray = new YArray();\n\n    const yValues = val.map((v) => toSharedType(v));\n    yArray.push(yValues); // yArray.push takes an array of values.\n\n    return yArray;\n  } else if (isObject(val)) {\n    const yMap = new YMap();\n\n    Object.entries(val).forEach(([key, v]) => {\n      yMap.set(key, toSharedType(v));\n    });\n\n    return yMap;\n  } else {\n    return val;\n  }\n};\n","import { Map as YMap, Array as YArray } from 'yjs';\nimport { getDiff } from 'recursive-diff';\nimport { clamp, isInteger, isString } from './utils';\nimport { toSharedType } from './toSharedType';\nimport { RecursiveDiffResult, RecursiveDiffResultOperation } from './recursive-diff.types';\n\n/** @desc Handles the operation from recursive-diff to patch the given yType */\nconst patchYType = (\n  yType: YMap<unknown> | YArray<unknown>,\n  operation: RecursiveDiffResultOperation,\n  property: string | number, // Either the Map key or Array index\n  value: unknown\n) => {\n  if (\n    operation === RecursiveDiffResultOperation.Add ||\n    operation === RecursiveDiffResultOperation.Update\n  ) {\n    const yValue = toSharedType(value);\n\n    if (yType instanceof YArray && isInteger(property)) {\n      if (operation === RecursiveDiffResultOperation.Update) yType.delete(property);\n\n      yType.insert(property, [yValue]);\n    } else if (yType instanceof YMap && isString(property)) {\n      yType.set(property, yValue);\n    } else {\n      throw new Error('Unsupported YAbstractType or property type did not match.');\n    }\n  } else if (operation === RecursiveDiffResultOperation.Delete) {\n    if (yType instanceof YArray && isInteger(property)) {\n      // This actually only works because the \"recursive-diff\" cancels inserts and deletions out into update operations\n      // [1, 2, 3] => [3] into [{op: 'update', index: 0, val: 3}, {op: 'del', index: 1}, {op: 'del', index: 2}]\n      // Therefore delete or insert operations are always last (never both, since that would be represented as an update).\n      // A more sophisticated solution would group deletions together to a single operation.\n      const clampedIndex = clamp(property, 0, yType.length - 1);\n      yType.delete(clampedIndex);\n    } else if (yType instanceof YMap && isString(property)) {\n      yType.delete(property);\n    } else {\n      throw new Error('Unsupported YAbstractType or property type did not match.');\n    }\n  }\n};\n\n/** @desc Recursively walk through path array until its length is one, at which point it performs the appropriate operation on the remaining property in the path. */\nconst traversePath = (\n  yType: YMap<unknown> | YArray<unknown>,\n  operation: RecursiveDiffResultOperation,\n  path: Array<string | number>,\n  value: unknown\n) => {\n  if (path.length === 0) {\n    throw new Error('Cannot traverse 0 length path.');\n  }\n\n  if (path.length === 1) {\n    patchYType(yType, operation, path[0], value);\n  } else {\n    const [currentSegment, ...restPath] = path;\n\n    if (yType instanceof YArray) {\n      if (!isInteger(currentSegment)) {\n        throw new Error('States diverged.');\n      }\n\n      const nextType = yType.get(currentSegment);\n\n      // NextType must also be an array or map because path.length >= 2.\n      if (!(nextType instanceof YMap || nextType instanceof YArray)) {\n        throw new Error('States diverged.');\n      }\n\n      traversePath(nextType, operation, restPath, value);\n    } else if (yType instanceof YMap) {\n      if (!isString(currentSegment)) {\n        throw new Error('States diverged.');\n      }\n\n      const nextType = yType.get(currentSegment);\n\n      // NextType must also be an array or map because path.length >= 2.\n      if (!(nextType instanceof YMap || nextType instanceof YArray)) {\n        throw new Error('States diverged.');\n      }\n\n      traversePath(nextType, operation, restPath, value);\n    } else {\n      console.warn('Encountered unsupported yType. Received:', yType);\n    }\n  }\n};\n\n/**\n * @desc Takes a rootMap that holds the values at the given sliceName. Then compares the old and new state to find the difference and apply that to the slice in the rootMap.\n * @param rootMap The yMap that holds the values to all slices.\n * @param sliceName Property name that contains the values on the rootMap.\n * @param a The old value.\n * @param b The new value.\n * */\nexport const patchYjs = (rootMap: YMap<unknown>, sliceName: string, a: unknown, b: unknown) => {\n  // Types of getDiff are inaccurate\n  const diff = getDiff(a, b) as RecursiveDiffResult;\n\n  // Applying diff in reverse to avoid problems when removing more than one item from an array,\n  // where the index of the item that should be removed moves after a previous one was removed.\n  // F.e.: diff(1[, 2], []) returns [{op: 'del', idx: 0}, {op: 'del', idx: 1}] but by the time\n  // we try to remove the second element, the array only has a length of 1. Thus index 1 would\n  // be out of bounds. Deleting from right to left circumvents this problem, while introducing\n  // it again but for insertions. To solve this problem, items should be inserted from left to\n  // right but removed right to left. A workaround exists inside the patchYType function, that\n  // simply clamps the accessed index to the length of the array. The method is limited to the\n  // recursive-diff algorithm though.\n  // diff.reverse(); // Won't work for multiple consecutive insertions.\n\n  diff.forEach(({ op, path, val }) => {\n    // \"path\" is undefined if a or b are primitive values.\n    traversePath(rootMap, op, [sliceName, ...(path || [])], val);\n  });\n};\n","import { Doc as YDoc, transact } from 'yjs';\nimport { Reducer, Store } from 'redux';\nimport { patchStore, SET_STATE_FROM_YJS_ACTION } from './patchRedux';\nimport { toSharedType } from './toSharedType';\nimport { patchYjs } from './patchYjs';\nimport { isArray, isObject } from './utils';\n\nexport { SET_STATE_FROM_YJS_ACTION } from './patchRedux';\n\n/** @desc This is the name of the yMap that is used on the yDoc that passed to the setup function. Can be used to persist the values on a server. */\nexport const ROOT_MAP_NAME = '__ReduxYjsBindingsRootMap';\n\n/**\n * @desc Initialises the bindings and registers listeners on yjs and teh redux store.\n * @param yDoc The y-document that is used to sync with other peers.\n * @param store The redux store containing the values that should be synced.\n * @param sliceName The name of the redux-subtree (slice) that contains the values.\n * */\nexport const bind = <S extends { [P in keyof S]: S[P] }, K extends keyof S & string>(\n  yDoc: YDoc,\n  store: Store<S>,\n  sliceName: K\n) => {\n  const rootMap = yDoc.getMap(ROOT_MAP_NAME);\n  const state = store.getState()[sliceName];\n\n  // Set initial values from store, while preventing overriding remote states.\n  if (isObject(state)) {\n    transact(yDoc, () => {\n      rootMap.set(sliceName, toSharedType({}));\n      patchYjs(rootMap, sliceName, {}, state);\n    });\n  }\n\n  if (isArray(state)) {\n    transact(yDoc, () => {\n      rootMap.set(sliceName, toSharedType([]));\n      patchYjs(rootMap, sliceName, [], state);\n    });\n  }\n\n  // Prevent reacting to our own changes.\n  let currentlyPatchingYjs = false;\n  let currentlyPatchingStore = false;\n\n  let currentState = store.getState()[sliceName];\n  const unsubscribe = store.subscribe(() => {\n    const prevState = currentState;\n    currentState = store.getState()[sliceName];\n\n    if (currentlyPatchingStore) return;\n\n    currentlyPatchingYjs = true;\n    transact(yDoc, () => {\n      patchYjs(rootMap, sliceName, prevState, currentState);\n    });\n    currentlyPatchingYjs = false;\n  });\n\n  const patchYjsFunction = () => {\n    if (currentlyPatchingYjs) return;\n\n    currentlyPatchingStore = true;\n    patchStore(store, rootMap, sliceName);\n    currentlyPatchingStore = false;\n  }\n\n  rootMap.observeDeep(patchYjsFunction);\n\n  return () => {\n    unsubscribe();\n    rootMap.unobserveDeep(patchYjsFunction);\n  }\n};\n\n/** @desc This is a utility function to enhance an existing reducer to react to the actions dispatched that are meant to set the state of the redux slice on incoming changes from yjs. */\nexport const enhanceReducer =\n  <S>(currentReducer: Reducer<S>): Reducer<S> =>\n  (state, action) => {\n    if (action?.type === SET_STATE_FROM_YJS_ACTION) {\n      return action.payload === undefined ? state : action.payload;\n    } else {\n      return currentReducer(state, action);\n    }\n  };\n"],"names":["SET_STATE_FROM_YJS_ACTION","RecursiveDiffResultOperation","isObject","val","Object","prototype","toString","call","isArray","Array","isString","isInteger","Number","toSharedType","yArray","YArray","yValues","map","v","push","yMap","YMap","entries","forEach","_ref","set","traversePath","yType","operation","path","value","length","Error","property","Add","Update","insert","yValue","Delete","clampedIndex","u","patchYType","restPath","slice","currentSegment","get","nextType","_nextType","console","warn","patchYjs","rootMap","sliceName","a","b","getDiff","op","concat","bind","yDoc","store","getMap","state","getState","transact","currentlyPatchingYjs","currentlyPatchingStore","subscribe","prevState","currentState","dispatch","type","payload","toJSON","patchStore","observeDeep","patchYjsFunction","unsubscribe","unobserveDeep","enhanceReducer","currentReducer","action","undefined"],"mappings":"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"}